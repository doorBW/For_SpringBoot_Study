# 자바 ORM 표준 JPA 프로그래밍 - 기본편
[강의링크](https://www.inflearn.com/course/ORM-JPA-Basic#)

## 0. JPA 소개 - **중요!!!**
### SQL 중심적인 개발의 문제점
- 기존에는 SQL 중심의 개발에서 벗어나기 어렵다!

### JPA 소개
- Java Persistance API
- Object-relational mapping
- 객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑
- JPA는 인터페이스의 모음(하이버네이트, EclipseLink, DataNucleus)
- SQL 중심적인 개발에서 객체 중심으로 개발이 가능해진다.

## 1. JPA 시작하기
### H2 DB Setting
### Java project (with Maven)

## 2. 영속성 관리 - 내부 동작 방식
### JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기
- **영속성 컨텍스트**

### 영속성 컨텍스트
- '엔터티를 영구 저장하는 환경'이라는 뜻

### 엔티티의 생명주기
- 비영속(new/transient)   
영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속(managed)   
영속성 컨텍스트에 관리되는 상태
- 준영속(detached)   
영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed)   
삭제된 상태

### 영속성 컨텍스트의 이점
- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

## 플러시
### 플러시 발생
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQl 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

### how to flush?
- em.flush() - 직접 호출
- 트랜잭션 커밋 - 자동 호출
- JPQL쿼리 실행 - 자동 호출

### 플러시는!
- 영속성 컨텍스트를 비우지 않는다.
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는 것!
- 트랜잭션이라는 작업 단위가 중요하다. -> 커밋 직전에만 동기화 하면됨.

## 준영속
- em.detach(entity)   
특정 엔티티만 준영속 상태로 전환
- em.clear()   
영속성 컨텍스트 초기화
- em.close()   
영속성 컨텍스트 종료

## 3. 엔티티 매핑
### @Entity
- @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다.
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity가 필수
- **주의**!!
    - 기본 생성자 필수
    - final 클래스, Enum, interface, inner 클래스에 사용x
    - 저장할 필드에 final 사용x
- @Table은 엔티티와 매핑할 테이블 지정

### Database 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- **이렇게 생성된 DDL은 개발 장비에서만 사용**
- DDL생성기능: @Column의 Nullable, length 등
    - DDL 자동 생성시에만 영향을 주고 JPA에는 영향을 주지 않는다.

### 필드와 컬럼 매핑
- @Transient: db랑 매핑하지 않을 것 명시

### 기본 키 매핑
- 권장하는 식별자 전략
    - 기본 키 제약조건: null아님, 유일, 변하면 안된다.
    - 미래까지 이 조건을 만족하는 자연키는 찾기가 어렵다.   
    대리키(대체키)를 사용하자.
    - 권장: Long형 + 대체키 + 키생성전략 사용
    - 비즈니스를 키로 끌고오는건 권장하지 않는다.!!

### 실전예제!
- 요구사항 분석과 기본 매핑 -> 코딩~!

## 4. 연관관게 매핑 기초
- 객체와 테이블 연관관계의 차이를 이해해야 한다.
- 객체의 참조 <-> 테이블의 외래키

### 양방향 연관관계와 연관관계의 주인
- 객체의 양방향 관계는 사실 양방향관계가 아니라, 서로 다른 단방향관계 2개다.
- 테이블은 외래키 하나로 두 테이블의 연관관게를 정의
- 연관관계의 주인
    - 연관관계의 주인만이 외래키를 관리(등록 수정)
    - 주인이 아닌쪽은 읽기만 가능
    - 주인은 mappedBy 속성 사용
    - 주인이 아니면 mappedBy 속성으로 주인 지정
    - 누구를 주인으로? 외래키가 있는 곳을 주인으로 정해라!

### 양방향 매핑시 주의점
- 연관관계의 주인에게 객체를 넣어줘야한다.
- But, 순수객체상태를 고려해서 항상 양쪽에 값을 설정하자.
- 이를 위해 연관관계 편의 메서드를 생성하자.
```java
public void setTeam(Team team) {
    this.team = team;
    team.getMembers().add(this);
}
```
- 양방향 매핑시에 무한 루프를 조심하자
    - ex) toString(), lombok, JSON 생성라이브러리
- **단방향 매핑만 잘 해두면, 양방향 매핑은 필요할때 추가하면 된다.**

## 5. 다양한 연관관계 매핑
- 고려사항 3가지
    1. 다중성
    2. 단방향, 양방향
    3. 연관관계의 주인
### 다대일: @ManyToOne
### 일대다: @OneToMany
- 일(1)이 연관관계의 주인
- 테이블 일대다관계는 항상 다(N) 쪽에 외래키가 있음
- 그래서, 객체와 테이블의 차이때문에 받내편 테이블의 외래키를 관리하는 특이한 구조가 되어버림.. -> 별로선호하지 않는 이유
- @JoinColumn을 꼭 사용해야한다. 그렇지 않으면 조인 테이블방식을 사용한다.
- 되도록 **다대일 양방향 매핑을 사용하자**
### 일대일관계: @OneToOne
- 다대일 매핑과 유사하다.
- 다대일과 같이, **외래키가 있는 곳이 주인**
### 다대다관계: @ManyToMany
- 실무에서 쓰지말자...
- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다관계로 표현할 수 없음.
- **연결테이블**을 추가해서, 일대다, 다대일관계로 풀어내야 한다.
- @ManyToMany with @JoinTable
- 실무에서는 추가정보가 필요한경우가 대다수인데, 연결테이블에는 매핑정보만 들어간다..
- **-> 연결테이블을 엔티티로 승격시키자!**
### 실전예제! 코딩~!

## 6. 고급매핑
### 상속 관계 매핑
- RDB는 상속 관계가 없다.
- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
    - 조인 전략   
    `@Inheritance(strategy = InheritanceType.JOINED)`
    - 장점
        - 테이블 정규화
        - 외래 키 참조 무결성 제약조건 활용가능
        - 저장공간 효율화
    - 단점
        - 조회시 조인을 많이 사용, 성능 저하
        - 조회 쿼리가 복잡함
        - 데이터 저장시 INSERT SQL 2번 호출

    - 통합 테이블로 변환 -> 단일테이블 전략   
    `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
    - 장점
        - 조인이 필요 없으므로 일반적으로 조회가 빠름
        - 조회 쿼리가 단순함
    - 단점
        - 자식 엔터티가 매핑한 컬럼은 모두 null 허용
        - 단일 테이블에 모든 것을 저장하므로 테이블이 커질수 있고 상황에 따라서 조회 성능이 오히려 느려질 수 있다.
    - 구현 클래스마다 테이블 전략   
    `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`
    - 이건 안좋아..!
    - 장점
        - 서브 타입을 명확하게 구분해서 처리할 때 효과적
        - not null 제약조건 사용 가능
    - 단점
        - 여러 자식 테이블을 함께 조회할 때 성능이 느림
        - 자식 테이블을 통합해서 쿼리하기 어려움

### @MappedSuperclass
- 공통적으로 사용할 것들!
- entity가 아니다 -> 테이블과 매핑되는 것이 아니다.
- 상속관계가 아니다.
- 직접 선언해서 이용할 일이 없기에 추상클래스를 권장