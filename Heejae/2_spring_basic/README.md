# 1. 객체 지향 설계와 스프링

## 스프링이란?

**필수**

- 스프링 프레임워크
- 스프링 부트
  - 스프링을 편리하게 사용할 수 있도록 지원
  - Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨

**선택**

- 스프링 데이터
- 스프링 세션
- 스프링 시큐리티
- 스프링 Rest Docs
- 스프링 배치
- 스프링 클라우드

**스프링의 핵심 개념, 컨셉?**

- 자바(객체 지향 언어) 언어 기반의 프레임워크
- 스프링은 *객체 지향 언어가 가진 강력한 특징*을 살려내는 프레임 워크

=> 즉, 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

## 좋은 객체 지향 프로그래밍이란?

객체 지향 프로그래밍의 강력한 특징 : **다형성**

자바 언의의 다형성의 역할은 인터페이스

- 다형성의 본질: 클라이언트를 변경하지 않고, 서버 구현 기능을 유연하게 변경할 수 있다.

- 인터페이스를 안정적으로 잘 설계하는 것이 중요

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP(single responsibility principle): 단일 책임 원칙
- OCP(Open/closed principle): 개방-폐쇄 원칙
- LSP(Liskov substituion principle): 리스코프 치환 원칙
- ISP(Interface segregation principle): 인터페이스 분리 원칙
- DIP(Dependency inversion principle): 의존관계 역전 원칙

다형성만으로 OCP와 DIP를 지킬 수 없다. **DI와 DI 컨테이너**가 필요하다.

## 객체 지향 설계와 스프링

- 이상적으로는 모든 설계에 인터페이스를 부여하자

- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입한 것도 방법이다.

# 2. 스프링 핵심 원리 이해1 - 예제 만들기

- ~ServiceImpl을 만드는 이유는? Service는 하나만 있는거 아닐까? 그냥 바로 ~Service를 구체 클래스로 만들어도 되지 않을까?

# 3. 스피링 핵심 원리 이해2 - 객체 지향 원리 적용

## IoC, DI, 그리고 컨테이너

### 제어의 역전 IoC(Inversion of Control)

- 프레임워크가 개발자가 호출할 코드를 대신 호출 해주는 것

- 우리 예제에서는 `AppConfig`가 구현 객체(`OrderServiceImpl` 같은 것)는 자신의 로직을 실행하는 역할만 담당할 뿐이지, 프로그램의 제어 흐름은 이제 AppConfig가 가져간다. `OrderServiceImpl`은 묵묵히 자신의 로직을 실행할 뿐이다.

### 의존관계 주입

- 정적 의존 관계: 실행 되기 전 알 수 있는 의존 관계. 이 예제에서 인터페이스에 대해 의존한다.
- 동적 의존 관계: 런타임에 의존하는 관계

둘을 잘 구분하자.

### IoC 컨테이너, DI 컨테이너

- 예제의 AppConfig 같은 것들을 IoC 컨테이너 또는 DI 컨테이너라고 한다.
- 요즘은 DI 컨테이너라고 많이 부른다.
- 또한, 어셈블러 또는 오브젝트 팩토리 등으로 불리기도 한다.

## 스프링으로 전환하기

```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```

spring 컨테이너를 생성하는 방법. Bean을 관리 해줌.

```java
applicationContext.getBean("memberService", MemberService.class);
```

bean 꺼내기. 이름은 메서드 이름으로 등록 된다. 두번 째 param은 타입이다.

# 4. 스프링 컨테이너와 스프링 빈

## 스프링 컨테이너 생성

- `ApplicationContext`는 스프링 컨테이너다.
- `ApplicationContext`는 인터페이스다.
- 스피링 컨테이너를 부를 때 `BeanFactory`, `ApplicationContext`로 구분해서 이야기한다. 근데 `BeanFactory`를 거의 사용 할 일이 없어서 `ApplicationContext`가 스프링 컨네이너라고 보면 된다.

- _빈 이름이 같아지면, 다른 빈이 무시되거나, 기존 빈을 덮어버린다. 요즘 스프링 버전에서는 팅겨버린다._

- 스프링 컨테이너 생성 과정

1. 스프링 컨테이너 생성
2. 스프링 빈 등록
3. 스프링 빈 의존관계 설정 - 준비
4. 스프링 빈 의존관계 설정 - 완료

## 컨테이너에 등록된 모든 빈 조회

## 스프링 빈 조회 - 기본

- 구체 타입으로 빈 조회를 하는 것은 좋지 않다

## 스프링 빈 조회 - 동일한 타입이 둘 이상

- 타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때 빈 이름으로 가져오면 된다.

## 스프링 빈 조회 - 상속 관계

- 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.
- 그래서 모든 자바 객체의 최고 부모인 `Object` 타입을 조회하면, 모든 스프링 빈을 조회한다.

## BeanFactory와 ApplicationContext

- `BeanFactory`: 스프링 컨테이너의 최상위 인터페이스. `getBean()`을 제공한다.

- `ApplicationContext`: BeanFactory 기능을 모두 상속받아서 제공한다. 빈 관리 및 검색 외에도 다양한 부가 기능이 있다.
  - 메세지 소스로 국제화 기능
  - 환경 변수
  - 애플리케이션 이벤트
  - 편리한 리소스 조회

## 다양한 설정 형식 지원 - 자바 코드, XML

## 스프링 빈 설정 메타 정보 - BeanDefinition

- 스프링이 유연하게 xml도 bean으로 만들 수 있는 이유가 `BeanDefinition`이라는 추상화 덕분이다.

# 5. 싱글톤 컨테이너

## 웹 애플리케이션과 싱글톤

싱글톤 패턴이 없다면 클라이언트가 요청 할 때마다 객체를 계속 생성해서 메모리 낭비를 한다.

이 문제를 해결하기 위해 해당 객체를 1개만 생성하고 공유하면 된다.

## 싱글톤 패턴

- 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 패턴

- private 생성자를 사용해서 외부에서 임의로 new 키워드로 사용하지 못하도록 막아야 한다.

## 싱글톤 컨테이너( = 스프링 컨테이너)

싱글톤 컨테이너는 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤으로 관리한다.

- 물론 싱글톤 방식 외에도 지원을 한다. -> 빈 스코프

## 싱글톤 방식의 주의점

- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너든, 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.

## @Configuration과 싱글톤

- AppConfig에서 `MemberRepository`을 생성하는 new 생성자 코드가 3번 호출 할 것인데, 이러면 싱글톤이 보장 안되는 것 아닌가? 그런데 싱글톤을 보장한다. 이에 대한 해답은 다음 장에서

## @Configuration과 바이트코드 조작의 마법

- CGLIB이라는 라이브러리가 AppConfig를 상속 받아 클래스를 만들어서 바이트 코드 레벨에서 코드를 조작해준다. 그래서 "Bean으로 등록할 객체가 존재하면 기존 것을 사용하고, 없으면 생성해주는" 로직을 생성한 뒤 스프링 컨테이너에 주입한다.

# 6. 컴포넌트 스캔

## 컴포넌트 스캔과 의존관계 자동 주입 시작하기

- 실무에서는 등록해야 할 빈들이 수백개가 될 것이므로 스프링이 제공해주는 컴포넌트 스캔과 `@Autowired`를 통해서 자동으로 빈을 등록 할 수 있다.

## 탐색 위치와 기본 스캔 대상

- 컴포넌트 스캔을 사용하고 싶으면 `@ComponentScan`을 설정 정보(`@AppConfig`)에 붙혀주기만 하면 된다.

- `@Component` 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.

- `@Autowired`는 의존관계를 자동으로 주입해준다. 대부분 생성자에 붙혀준다.

- `@SpringBootApplication` 안에 `@ComponentScan`이 들어있다.

## 필터

## 중복 등록과 충돌

- Bean의 이름이 같으면 충돌한다.

- 수동 빈 등록이 자동 빈 등록을 오버라이딩 한다. 대신 수동 빈 등록시 로그를 남겨준다.

- 하지만 현실은 설정이 꼬이기 쉽상이므로 수동 빈 등록과 자동 등록이 충돌나면 오류가 발생하도록 최근에 스프링 부트가 기본 값을 바꿨다.(스프링부트로 실행 했을 때 발생한다.)
